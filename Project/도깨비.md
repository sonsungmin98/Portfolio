## Sequence Block

![image](https://github.com/user-attachments/assets/8a935ace-e8d5-48ad-b26f-bcbcf6c2c9e4)


기획자가 튜토리얼 및 게임의 제어가 필요한 부분에서 사용할 수 있는 시스템을 직접 제작할 수 있게 만들기 위해 만든 툴입니다. 툴을 만들 때에는 기획자 혹은 그래픽 사람이 이해하기 쉽게 직관적이고 간편 해야 한다고 생각하였고 이런 부분을 고려하여 제작하였습니다.  

ActType에는 어떠한 행동을 할 것인지 선택합니다. 물론 중복도 선택 가능하며 WaitType에서는 다음 블록으로 넘어가는 조건을 정할 수 있습니다. 이렇게 구성된 블록으로 각 플로우마다 해야 할 일을 입력합니다. 이를 통해 기획자는 튜토리얼을 설계할 수 있습니다. 또한 튜토리얼뿐만 아니라 강제적으로 플로우를 주고 싶을 때 사용할 수 있습니다. 여러 Type을 표현하기 위해 Flag 연산을 했습니다. 

### Act Type

|타입|인자|설명|
|---|---|----|
|Nothing|		|아무 행동도 하지 않는다.
|Set Character|Position	Vector3(Position)|특정 캐릭터를 이동시킨다.|
|Play Dialog Box|String|블록에 등록된 텍스트를 말풍선 형태로 출력한다.|
|Set Icon|GameObject|아이콘을 배치시킨다.|
|Clear Icon|Int (Flow Number)|아이콘을 제거한다.|

### Wait Type

|타입|인자|설명|
|---|---|----|
|Wait For Second|Float|몇 초 후에 멈춘다.|
|Wait Until Space| |Space 바를 누를 때까지 멈춘다.|
|Wait Until Area Space|Vector3(Position)|특정 구역에 도착해서 SPACE 바를 누를 때까지 멈춘다.|
|Wait Util Arrive Area|Vector3(Position)|특정 구역에 도착할 때까지 멈춘다.|
|Wait Until Dialog| |말풍선이 끝날 때까지 멈춘다.|

### 문제점
사실 위의 것들을 구현하면서 몇 가지 문제점이 생겼습니다.
1. 이 시스템이 다른 클래스들과 의존성이 생깁니다. (플레이어, 도깨비, 말풍선…)
2. 블록의 경우 Custom Editor와 Scriptable Object로 만들었습니다. 그러다 보니 사용하지 않는 다른 ActType 값도 들고 있습니다. (물론 사용자는 다른 ActType의 멤버를 보지 못합니다.)
3. 새로운 기능을 만들고 싶을 때에도 코드를 수정해야 한다.

### 해결을 위한 노력
사실 위의 내용 중 완벽히 해결한 경우는 없습니다. 이 작업이 후반 작업이었기 때문에 작업 요청이 늦게 들어와 (공모전)마감기한, 볼륨 등을 고려했을 때 적당히 타협을 한 결과물입니다.  
  
1번의 경우에는 해결을 위해 여러가지를 고민했습니다. “이벤트 큐나 관찰자 패턴을 이용해 클래스 간의 결합도를 낮출까”도 생각 했지만 사실 거대한 시스템을 제작하기 위한 시간과 제가 작업하지 않은 부분까지 건드려야 하는 문제가 있었습니다. 그렇기 때문에 타협한 방법이 세부사항의 경우 제작하는 시간이 오래 걸리지 않을 것이라 생각하였고 이 시퀀스 시스템을 위한 각 클래스를 새로 만들기로 했습니다. 그리고 제가 작업하지 않았던 플레이어와 도깨비(펫)의 경우에는 기존 클래스를 상속받아 기존의 제작된 기능을 랩핑하여 재사용 하였습니다.  
  
2번의 경우 데이터를 나눌까 하다가 오히려 삽질이 될 거 같아(Editor도 수정이 들어가야 하기 때문) 일단 그대로 진행하였습니다.  
  
3번의 경우에도 기획자를 위해 기능을 제작하고 추가할 수 있는 툴을 만드는 것보다 제가 직접 만들어 주는 것이 코스트가 적다는 것으로 생각하여 그대로 진행하였습니다. 그래서 이 부분을 인지하고 졸업작품에서 비슷한 기능을 만들 때 기능의 추가와 삭제가 블루프린터에서 가능하게 제작했습니다.

## CSV Parsing Tool
![image](https://github.com/user-attachments/assets/449be03e-6162-4462-9fac-42a2cec31808)

이 부분은 파싱 하고싶은 CSV 파일을 올려서 버튼을 누르면 자동으로 데이터를 파싱 하게 만들었습니다. 이 부분도 사용자가 사용하기 편하게 제작하였습니다. 제작할 때 사용자(비 프로그래머)의 경우에는 버튼 하나 누르는 것도 어려워한다고 생각하고 만들었습니다.  
처음에는 데이터의 변경됨에 따라 자동으로 업데이트 되게 만들까 하다가 그럴 경우 기획자가 실수하거나 예상 못하게 업데이트가 되는 문제가 발생할 거 같아 CSV 파일만 넣고 Parse Data 버튼을 누르면 자동으로 값이 업데이트가 되게 만들었습니다.  

## 몬스터 FSM
몬스터의 FSM의 경우에는 단순하게 기본 FSM 구조에 따라 제작하였습니다. 이 부분도 아쉬움이 많이 남았던 시스템 이였습니다
![image](https://github.com/user-attachments/assets/5fb45203-8ba2-4b03-9eb8-0505a13bbb4a)

위의 클래스 다이어그램은 CryMonster의 FSM에 대한 내용을 정말 간단하게 표현한 것입니다. 어떻게 보면 OOP의 구조를 따라 잘 만들었으며 완벽하지 않지만 적당히 나쁘지 않은 구조로 볼 수도 있습니다. 


하지만 문제점이 보이는 부분이 몇 개 있습니다. 
1. 몬스터 FSM이 각 몬스터와 1:1 대응된다는 점입니다. 그러다 보니 몬스터를 만들 때마다 각 몬스터에 맞는 FSM을 제작해야 합니다.  
2. FSM과 상관없지만 현재 각 몬스터는 너무 많은 책임을 지고 있습니다. 한 클래스에서AI, 물리(움직임), 연출(애니메이션, 이펙트)… 등등 너무 클래스가 방대합니다.
  
이것 이외에도 문제가 보입니다. 이러한 문제점을 개선시키려 했지만 이미 너무 방대한 클래스, 각 클래스 간의 강한 결합도, 클래스의 약한 응집성, 세부 구현마저 너무 다른 클래스와의 의존성이 높아 재사용이 어렵다는 이유로 인해 차라리 프로젝트를 다시 만드는 것이 코스트가 적게 들 것으로 판단했습니다. 
그래서 이 프로젝트의 리팩토링은 잠시 미뤘습니다.이번 기회로 최대한 확장성 있는 구조로 기획의 변경에 따라 유동적으로 대응할 수 있는 시스템을 만들려고 노력하게 되었습니다. 
그리고 앞으로는 중간중간 리팩토링을 통한 코드의 재설계, 코드의 문서화 등으로 건강한 프로젝트를 진행하려고 합니다. 
나중에 프로젝트의 볼륨이 커질수록 감당할 수 없는 커다란 짐덩이로 돌아온다는 것을 느꼈습니다. 
그러다 보니 실제로 졸업작품에서 FSM을 설계했을 때에는 이번의 문제점을 통해 개선된 FSM 만들 수 있었습니다. 
클래스도 물론 잘 나눠 각각의 클래스가 한가지 책임만을 가지게 만들었습니다.


